=#top AFW Документация

* [#general Общие принципы]
* [#uri Разбор адреса]
* [#controller Контроллеры]
* [#model Модели]
* [#db Работа с базой данных]
* [#cache Кэш]
* [#file Обработка файлов и изображений]
* [#utils Утилиты]
** [#utilDebugLog Вывод отладочной информации]
** [#utilSession Сессии]
** [#utilUtils Дополнительные функции]
** [#utilParser Парсер]
* [#models Базовые модели]
** [#modelSettings Настройки]
** [#modelSupervisor Администратор]
** [#modelUser Пользователь]
** [#modelStatistics Статистика]
** [#modelMap Карта]
** [#modelBasket Корзина]
* [#controllers Базовые контроллеры]
** [#controllerLayout Макет]
** [#controllerSimpleList Простой список]
** [#controllerPaginator Страницы]
** [#controllerForm Форма]



==#intro Введение

Этот документ - документация к веб-фреймворку AFW(AFW FrameWork). Данный фреймворк предназначен как для начинающих веб-разработчиков, которые хотят научиться создавать свои проекты с нуля, так и для опытных, желающих полностью контролировать процесс загрузки страниц и работу проекта в целом, не допуская никаких лишних действий со стороны фреймворка.

В данный момент документация весьма краткая, со временем будет дополняться.

[https://github.com/Aequiternus/afw Исходный код] [http://inmemo.net/project/afw Ошибки и предложения]



==#general Общие принципы

Структура папок строго соответствует [http://www.php.net/manual/ru/language.namespaces.rationale.php пространствам имен], которые фреймворк активно использует. В конфигурации каждого приложения должна быть определена функция автоматической загрузки классов. Расположение файлов классов зависит от конкретного проекта и определяется этой функцией. По умолчанию корневая папка классов и корневое пространство имен совпадает с корневой папкой приложения.

'''
function __autoload($class)
{
    require str_replace('\\', '/', $class) . '.php';
}
'''

Это позволяет забыть о том какие файлы необходимо подключить с помощью `include` или `require`, и в то же время при работе приложения всегда будут подключены только необходимые файлы.

Все файлы фреймворка расположены в папке и пространстве имен `afw`.

Фреймворк основан на распространенном и удобном для разработки веб-приложений шаблоне программирования MVC(Model-View-Controller, Модель-Представление-Контроллер). В связи с этим, в фреймворке существует два основных пространства имен: `m` для моделей и `c` для контроллеров, а также папка `v` для представлений (шаблонов).

Ресурсные файлы - те файлы которые используются на html-страницах: css, js, изображения и др. Располагаются эти файлы в папке `res`. Документация в папке `doc`, файлы локализации в папке `locale`. Классы, написанные сторонними разработчиками, расположены в папке `ext`.



==#uri Разбор адреса

Для разбора адреса предусмотрен специальный контроллер `afw\c\Uri`. С помощью метода `addPattern` можно задать регулярное выражение и соответствующую ему функцию-обработчик, аргументом которой являются [http://www.php.net/manual/ru/function.preg-match-all.php результаты поиска] регулярного выражения. Обработчик должен вернуть контроллер, описание работы которых будет ниже.

После установки всех необходимых адресов можно получить соответствующий текущему адресу контроллер с помощью метода `getController`, или сразу запустить отрисовку с помощью этого контроллера `renderController`.

'''
$uri = afw\c\Uri::instance();

$uri->addPattern(
    '`^blog/post-(\d+)$`', # рег. выр. адреса записи в блоге, например /blog/post-123
    function ($matches)
    {
        $postId = $matches[1];              # получение номера записи в блоге
        $controller = new c\Post($postId);  # создание контроллера записи в блоге
        return $controller;
    }
);

$uri->renderController();
'''

Обратите внимание, что контроллер `afw\c\Uri` автоматически убирает начальные и конечные слэши из адреса перед проверкой. Для получения преобразованного адреса используйте `afw\c\Uri::current()`.

Контроллер `afw\c\Uri` позволяет установить обработчик исключений, который будет вызван если ни один шаблон адреса не подошел, обработчик вернул не класс контроллера или в случае возникновения любого другого исключения. Аргументом обработчика в данном случае является исключение. Для отображения информации об исключении предусмотрен базовый контроллер `afw\c\Exception`.

'''
$uri->setException(function($exception)
{
    return new afw\c\Exception($exception));
});
'''

На ранних этапах создания приложения может оказаться очень полезным универсальный контроллер `afw\c\Uri::variable`, который просто вызывает у класса, указанного в первом аргументе, метод, указанный во втором аргументе, с параметрами переданными в третьем аргументе. Четвертым аргументом можно указать фильтр допустимых классов и методов в виде массива (значениями являются имена классов или подмассивы методов, в этом случае имя класса используется в качестве ключа). Ниже представлен самый простой пример регулярного выражения и обработчика для этого контроллера.

'''
# namespace/class:method/arguments
# http://example.com/c/Post:update/123
# http://example.com/c/Photo:get/321
$uri->addPattern(
    '`^([\w/]+):(\w+)(/.*)?$`',
    function ($matches)
    {
        return afw\c\Uri::variable(
            '\\'.str_replace('/', '\\', $matches[1]),
            $matches[2],
            explode('/', trim(@$matches[3], '/')),
            [
                '\c\Post'  => ['insert', 'update', 'delete', 'get', 'getList'],
                '\c\Photo' => ['insert', 'update', 'delete', 'get', 'getList'],
            ]
        );
    }
);
'''

Крайне не рекомендуется использовать контроллер `afw\c\Uri::variable` без фильтра.



==#controller Контроллеры

Базовый класс контроллеров `afw\c\Controller` очень прозрачен и представляет простой и гибкий инструмент работы с представлениями. Его функциональность можно разбить на три составляющие: подключение своих представлений, добавление дочерних контроллеров, обворачивание контроллером-макетом (layout).



=== Подключение представлений

Для подключения представления достаточно использовать метод `setViewFile` или `setView`. Аргументом для первого метода является путь к файлу представления (шаблону), а для второго может быть имя класса (`__CLASS__`) или метода (`__METHOD__`), который автоматически будет преобразован в соответствующий путь к файлу. Для второго метода принято заменять в пути папку (пространство имен) `c` на `v`.

'''
namespace c;

class StaticPages
{
    static function help($id)
    {
        $c = new \afw\c\Controller($id);
        $c->setView(__METHOD__); # путь: v/StaticPages/help.php
        return $c;
    }

    static function faq($id)
    {
        $c = new \afw\c\Controller($id);
        $c->setView(__METHOD__); # путь: v/StaticPages/faq.php
        return $c;
    }
}
'''

Можно установить несколько представлений подряд. В этом случае каждое последующее представление будет завернуто в предыдущее и будет вызываться на месте вызова `$this->contents()` предыдущего представления. Это очень удобно использовать при наследовании контроллера. Например у вас есть контроллер отвечающий за внешнее оформление страницы, и, наследуя его, вы пишете контроллер конкретной страницы. Тогда достаточно установить в конструкторе страницы новое представление после вызова родительского конструктора.

'''
namespace c;

class ExampleLayout extends \afw\c\Controller
{
    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/ExampleLayout.php
    }
}

class ExamplePage extends ExampleLayout
{
    function __construct()
    {
        parent::construct();
        $this->setView(__CLASS__); # путь v/ExamplePage.php будет завернут в v/ExampleLayout.php
    }
}
'''

'''
<?php /* файл v/ExampleLayout.php */ /* @var $this c\ExampleLayout */ ?>
<html>
<!-- оформление сверху -->
<?php $this->contents() ?>
<!-- оформление снизу -->
</html>
'''

'''
<?php /* файл v/ExamplePage.php */ /* @var $this c\ExamplePage */ ?>
<h1>Hello World!</h1>
'''

При отрисовке (вызове метода `render`) экземпляра класса `ExamplePage` получится следующий html-код.

'''
<html>
<!-- оформление сверху -->
<h1>Hello World!</h1>
<!-- оформление снизу -->
</html>
'''

Аналогичным образом можно установить новое представление до родительского конструктора, тогда представления будут вложены друг в друга с точностью до наоборот - представление родительского класса будет вложено в представление дочернего. Использовать данный подход можно если, например, у вас есть некоторые данные, которые нужно выводить в разном виде на экран и на печать.

'''
namespace c;

class DataSheet extends \afw\c\Controller
{
    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/DataSheet.php
    }
}

class DataSheetPage extends DataSheet
{
    function __construct()
    {
        $this->setView(__CLASS__); # обвернуть для вывода на экран в v/DataSheetPage.php
        parent::construct();
    }
}

class DataSheetPrint extends DataSheet
{
    function __construct()
    {
        $this->setView(__CLASS__); # обвернуть для вывода на печать в v/DataSheetPrint.php
        parent::construct();
    }
}
'''

Свободно используйте оба подхода в зависимости от конкретных задач и личных предпочтений.



=== Добавление дочерних контроллеров (`push`)

В контроллер можно добавить любые (не обязательно одного класса) дочерние контроллеры с помощью метода `push`. Все дочерние контроллеры будут отрисовываться в порядке добавления в месте вызова `$this->contents()` в конечном представлении.

'''
namespace c;

class ExampleForm extends afw\c\Controller
{
    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/ExampleForm.php

        $this->push(new InputText('login'));
        $this->push(new InputPassword('pass'));
    }
}

class InputText extends afw\c\Controller
{
    public $name;

    function __construct($name)
    {
        $this->setView(__CLASS__); # путь: v/InputText.php
        $this->name = $name;
    }
}

class InputPassword extends afw\c\Controller
{
    public $name;

    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/InputPassword.php
        $this->name = $name;
    }
}
'''

'''
<?php /* файл v/ExampleForm.php */ /* @var $this c\ExampleForm */ ?>
<form>
<h1>Example Form</h1>
<?php $this->contents() ?>
</form>
'''

'''
<?php /* файл v/InputText.php */ /* @var $this c\InputText */ ?>
<input type="text" name="<?= $this->name ?>" />
'''

'''
<?php /* файл v/InputPassword.php */ /* @var $this c\InputPassword */ ?>
<input type="password" name="<?= $this->name ?>" />
'''

При отрисовке экземпляра класса `ExampleForm` получится следующий html-код.

'''
<form>
<h1>Example Form</h1>
<input type="text" name="login" />
<input type="password" name="pass" />
</form>
'''



=== Обворачивание контроллером (`wrap`)

Чтобы обвернуть представление контроллера, не обязательно использовать наследование, можно также воспользоваться методом `wrap`. Обратите внимание, что в данном случае, необходимо вызывать отрисовку (метод `render`) у исходного контроллера, а не у контроллера-макета, в который будет завернут исходный контроллер. Данный подход удобен при использовании уже готовых классов, когда наследование невозможно или не удобно.

'''
namespace c;

class ExampleLayout extends afw\c\Controller
{
    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/ExampleLayout.php
    }
}

class ExamplePage extends afw\c\Controller
{
    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/ExamplePage.php
    }
}

$page = new ExamplePage();
$page->wrap(new ExampleLayout());
$page->render();
'''

Результат отрисовки будет такой же, как если бы `ExamplePage` наследовался от `ExampleLayout`.

Можно использовать несколько оберток подряд, в этом случае каждая последующая обертка будет обворачиваться вокруг предыдущей.



==#model Модели
